pragma solidity ^0.4.4;

contract malware{
    
    struct Node{            //   each node models each device on the network
        address nodeAdress; //   adress of the node
        uint trustValue;    //   trust value assigned to the node
        uint perCentMalware;//   percent probability calculated at the node
    }

    //	variables so that they can be accessed directly in the web3.js file
    address addedAddress;
    uint prob;    
    
    Node[] allNodes;    //  stores all Nodes in the network
    
    //  new nodes in network to be added with the help of a addNewNode() function
    
    function addNewNode(address newNodeAdress) public payable
    {
		allNodes.length ++;						   //  update length of Node array
		allNodes[allNodes.length-1] = Node(newNodeAdress,50,200);  	   //  nodes with default values
		addedAddress = allNodes[allNodes.length - 1].nodeAdress;   		   //  returns address of last node
    }
    
    //  remove a node from network using removeNode()
    
    function removeNode(address removeAdress) public payable
    {
        for(uint i = 0; i < allNodes.length - 1; ++ i)
        {
        	if(allNodes[i].nodeAdress == removeAdress)
        	{
        		//	remove node by shifting all Nodes after the removed Node to the left
        		for(uint j = i+1; j < allNodes.length; ++ j)
        			allNodes[j-1] = allNodes[j];
        		//	update array length
        		allNodes.length --;
        		break;
        	}
        }
    }
    
    //  busy() return true if all the percent probabilities are not still <=100
    //  default is set to 200
    //  to ensure that all nodes run the python script before calculation of consensus
    function busy() public payable returns (bool isBusy)
    {
        for(uint i=0; i < allNodes.length; ++i)
        {
            if(allNodes[i].perCentMalware == 200)			   //  calculated value must be between 0-100 (percentage)
                return true;						   //  if value == 200 => Node has not calculated the value
        }
        return false;
    }
    
    //  onClick() executes on button click in javaScript
    
    function onClick() public payable
    {
        //  sendFile();===> How can it be done in solidity?
        //  sendFile sends file a node has to all nodes in network
        //  runPythonScript(); ===> How can it be done in solidity?
        //                     ===> Should it be called for each node
        //                          or should it be called only once for all nodes
        while(busy())
            {} //  statement has no effect
    }
    
    
    //  a consensus value will be calculated using values stored in nodes
    
    function consensus() public payable 		//  returns mean of all probabilities
    {
        if(allNodes.length == 0)
        {
            prob = 300;
            return;
        }
        uint den = 0;
        uint consent=0;
        //  calculation of weighted-mean
        for(uint i=0; i < allNodes.length; ++i)
        {
            consent += allNodes[i].trustValue*allNodes[i].perCentMalware;
            den += allNodes[i].trustValue;
        }
        
        consent /= den;
        
        //  trust values of nodes will be modified based on statistical heuristics
        
        //  update trust by standard deviation from consensus
        for(i = 0; i < allNodes.length; ++i)
        {
            uint dev;
            if(allNodes[i].perCentMalware > consent)
                dev = allNodes[i].perCentMalware - consent;
            else
                dev = consent - allNodes[i].perCentMalware;
            allNodes[i].trustValue = 100 - dev; // never remains at zero
            // issue: the new trust value of node depends only on its last run, not the total history
            allNodes[i].perCentMalware = 200; // setting it to value for busy() 
        }
        prob = consent;
    }

    function getProb() public payable returns(uint)
    {
	return prob;	
    }

    function getLength() public payable returns(uint)
    {
	return allNodes.length;
    }

    function getAddedAddress() public payable returns(address)
    {
	return addedAddress;
    }
}
